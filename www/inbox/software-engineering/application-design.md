## Service container (IoC, DI)

-   Возможность работы с контекстами (как дополнительные слои над базовыми сервисами).
    -   Скажем, зарегистрировать HttpContext/HttpRequest/HttpResponse, но не только. Любые декодированные в HTTP-pipeline данные могут регистрироваться с использованием SomeAppSpecificContext, а не размещаться в привычном строковом или объектном (boxing) словаре контекста.
    -   Реализация механимзмов форматирования и в целом реакции на ошибки в зависимости от контекстов.
    -   Или, как я писал в заметках ранее, namespaces для контейнера. Где namespaces - расширение примитивных keyed-service.

## Flow

-   For<TRequest>().When(...).Expect(...);
    -   По умолчанию все процессы поразумеваются как параллельные.
    -   Чем-то похоже на BDD. Не исключено, что это оно и есть.
    -   Также похоже и на регистрацию сервисов.
-   Для перехода из одной категории в другую можно описывать самые разные стратегии (также в сервис-контейнере). Скажем, взять Valid<> -> Preprocessed<>, для которой определить асинхронный запуск всех сервисов, Task.WaitAll и собственно трансформацию Valid<> -> Preprocessed<>.

## Тяжёлая судьба "Sign In request"

-   HTTP pipeline (Http<SignInRequest>)
    -   Журналирование. Просто проходит через фильтр. Пишет в некий IEventLog.
        -   Http<SignInRequest> -> Http<SignInRequest>?
        -   Может быть несколько команд для журналирования в разные провайдеры, выполнять параллельно.
        -   Может быть полностью асинхронным.
    -   Аутентификация. Проверяет на IP, JWT. Расширяет/создаёт context. Потенциально генерирует ошибки 401/403. Authenticated<SignInRequest>.
        -   Может понадобиться доступ к хранилищу.
        -   Может быть несколько команд.
    -   Интеллектуальный load balancer.
-   JSON декодирование. Потенциально генерирует ошибку 400. Может понадобиться доступ к настройкам (де)сериализации.
    -   Json<SignInRequest> -> NotValidated<SignInRequest>
-   Валидация. Потенциально генерирует ошибку 422.
    -   Json<SignInRequest> -> Valid<SignInRequest>
    -   Json<SignInRequest> -> Invalid<SignInRequest>
    -   Может быть цепочка валидаций для различных интерфейсов. В том числе параллельных.
-   Может быть какой-то дополнительный препроцессинг запроса (Preprocessed<SignInRequest>).
    -   Проставить дату запроса, чтобы проконтролировать хаммеринг. Pass-through.
    -   Подсолить Password. GDPR hashing. Pass-through.
    -   Теоретически все процессы, которые могут быть распараллелены и мы ожидаем Task.WaitAll.
-   Alerting. Генерация дополнительной асинхронной ветви обработки с отправкой уведомлений.
    -   В процессинге запросов выглядит не очень, поскольку в нём ожидается выполнение всех ветвей, а alerting может быть полностью автономным. Плюс, ему может понадобиться уже сформированный SignInRequest.
-   Отправка запроса в базу
    -   А если REST? И куда девать остальное "мясо" бизнес-команды?
    -   Автоматический роутинг в базу (Preprocessed<> -> DbRequest<>) для определённых категорий запросов?
    -   Есть такой пользователь
    -   Ошибка базы (SomeDbException)
    -   Нет такого пользователя (UserNotFoundException)
    -   Хаммеринг (следующие попытки будут доступны через...) (UserHammeringException)
-   Обработка ошибок (Exception -> FormattedException<TException>)
    -   Журналирование
    -   Уведомления
    -   Редирект на сконфигурированную страницу для ошибки
    -   Форматирование и перевод ошибок
