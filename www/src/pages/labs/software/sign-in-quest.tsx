import React from "react";
import { Layout } from "../../../templates/layout";

export const SignInSaga = () => (
	<Layout>
		<header>
			<h1>Приключения Sign-In</h1>
		</header>

		<section>
			<h2>Преамбула</h2>

			<p>
				Практически всем известна операция "Sign In", когда мы идентифицируемся на
				каком-нибудь сайте. Несмотря на кажущуюся простоту, у этого запроса непростая
				история и он может стать хорошим экспонатом для исследования подхода в дизайне
				приложений в экосистеме .NET.
			</p>
		</section>

		<section>
			<h2>Теории</h2>

			<p>
				Есть несколько теорий, которые интересно рассмотреть в контексте этого исследования:
			</p>

			<ol>
				<li>
					<a href="#TODO:">Теория категорий.</a>
				</li>
				<li>
					<a href="#TODO:">
						Теория типов, унивалентная теория типов, гомотопическая теория типов (HoTT).
					</a>
				</li>
				<li>
					<a href="#TODO:">Конструктивное программирование.</a>
				</li>
				<li>
					<a href="#TODO:">
						Функциональное программирование, dependently typed programming (во многом
						как реальные практики использования теории типов, теории категорий и т.п.).
					</a>
				</li>
			</ol>
		</section>

		<section>
			<h2>Workflow</h2>

			<h3>Cases</h3>
			<p>
				Alerting. Были ситуаций, когда возникала необходимость анализировать параметры
				запроса и при его аномальных значениях формировать уведомление. При этом
				существующий workflow не менялся. Эта задача похожа на тонкий тюнинг журналирования.
				Не исключено, что он может и менять Workflow. Можно добавить соответствующий кейс
				для главного действующего лица (SignIn).
			</p>

			<h3>InBox</h3>
			<p>
				Исследовать railway-концепции и маршрутизацию в целом. В широком смысле этого слова
				(от транспортных артерий то цифровых сетей).
			</p>
			<p>
				Эксплуатировать шаблон <a href="#TODO:">State</a>. Просто его инстанцирование может
				быть более замысловатым, а сам он может участвовать в формировании класса запроса
				(или категорией-обобщением запроса).
			</p>
		</section>

		<section>
			<h2>InBox</h2>

			<p>
				Одна из причин выбора платформы .NET заключается в том, что помимо гаммы языков,
				которые дают почти максимум возможностей для самых разносторонних экспериментов (C#,
				F#, F*), она также предлагает и мощные средства рефлексии, динамической компиляции и
				управляемой компиляции. Это очень важно, поскольку есть мнение, что не обязательно
				все возможности по валидации программы должны быть возложены на compile-time. И
				некоторые фазы, которые, скажем, Haskell реализует при весьма медлительной
				компиляции или возможности вроде dependent types, которые в самом C# отсутствуют,
				могут стать частью его runtime-ядра, который используя рефлексию и динамическую
				компиляцию может достраивать приложение на лету. По сути, классический переход
				compile &rarr; runtime может дополниться ещё одним этапом compile &rarr;
				meta-runtime &rarr; runtime. В качестве альтернативы может выступить управляемая
				компиляция, где рефлексию заменит анализ AST а динамическую компиляцию -
				кодогенерация.
			</p>

			<p>
				Dependent-types программирование может быть реализовано в рантайме. Для workflow
				можно давать определение, что в этом направлении идут (в эту категорию попадают) те
				запросы, где login и пароль не пустой, что есть некоторый Valid&lt;TRequest&gt;.
			</p>

			<p>
				Json&lt;TRequest&gt; может реализовывать парсинг именно заданного запроса TRequest.
				Скорее всего, сама категория JSON может исчезнуть и выродиться в морфизм. Вместо
				разбора JSON как универсальной структуры данных, создавая ещё одну сложную
				конструкцию в памяти, можно линейно читать входящий HTTP-поток и тут же формировать
				TRequest, без посредников и практически с встроенной валидацией поскольку по сути
				ориентируется на схему заданную TRequest. На примере SignIn он может прочитать
				первый символ и если квадратная скобка а не фигурная, то сразу выдать исключение.
				Если за фигурной скобкой не идёт имя "login" или "password", то также выдать
				исключение и т.п. Аналогичную ситуацию можно наблюдать при чтении из базы данных и
				записи в неё, когда (де)сериализация может производиться непосредственно из
				транспортного протокола базы данных и именно для заданного формата данных. Без
				использования дополнительных посредников вроде DataSet, SqlDataRecord, которые
				дублируют ещё и метаинформацию. Если попробовать подвести индуктивный итог
				рассуждению, то ни JSON, ни SqlDataRecord не являются продуктами, которые нас
				интересуют, что ставит под сомнение рациональность их существования.
			</p>

			<p>
				Важно не забыть рассмотреть и то, как данные для SignIn будут представлены в базе,
				предполагая, что мы не знаем, кто именно идентифицируется - пользователь или внешняя
				система. Не знаем как - логином и паролем или через социальную сеть и т.п.
			</p>

			<p>
				Что, если использовать нечто похожее на columnar-storage, но применительно к дизайну
				аспектов (интерфейсов) класса-запроса. Вместо того, чтобы создавать композитный
				класс, их реализующий, можно хранить его аспекты отдельно (с кодом запроса). А
				workflow может определяться через населённость алгебраических классов. Например,
				некий обработчик может ожидать Valid+Authenticated. Интуитивно, очень интересно бы
				выглядели типичные конструкции CRUD-запросов, где львиная доля полей в части
				INSERT/UPDATE/SELECT пересекается. Для этой цели можно расширить немного судьбу
				SignIn-запроса механизмами добавления, обновления, блокировки пользователя.
			</p>

			<p>
				Исследуя реализации очень важно анализировать, как сложно даются те или иные
				изменения. Они, по возможности, должны выглядеть итеративно. И добавлять новый
				функционал без стресса.
			</p>

			<ol>
				<li>
					<a href="https://habr.com/ru/post/182340/">
						F* – новый язык с зависимыми типами для .Net
					</a>
				</li>
			</ol>
		</section>
	</Layout>
);

export default SignInSaga;
